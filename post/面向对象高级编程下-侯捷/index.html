<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; 面向对象高级编程下-侯捷 - LymanLife</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="lyman" /><meta name="description" content="1. Conversion function, 转换函数 class Fraction { // 函数分数 public: Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {} operator double() const { // 转换函数 return (double) (m_numerator / m_denominator) } private: int m_numerator; //分子 int m_denominator; // 分母 }; Fraction f(3, 5); double d = 4 &#43; f; // 调用oper" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.78.2 with theme even" />


<link rel="canonical" href="http://lyman.fun/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B8%8B-%E4%BE%AF%E6%8D%B7/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; 面向对象高级编程下-侯捷" />
<meta property="og:description" content="1. Conversion function, 转换函数 class Fraction { // 函数分数 public: Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {} operator double() const { // 转换函数 return (double) (m_numerator / m_denominator) } private: int m_numerator; //分子 int m_denominator; // 分母 }; Fraction f(3, 5); double d = 4 &#43; f; // 调用oper" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://lyman.fun/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B8%8B-%E4%BE%AF%E6%8D%B7/" />
<meta property="article:published_time" content="2019-05-21T10:25:00+00:00" />
<meta property="article:modified_time" content="2019-05-21T10:25:00+00:00" />
<meta itemprop="name" content="C&#43;&#43; 面向对象高级编程下-侯捷">
<meta itemprop="description" content="1. Conversion function, 转换函数 class Fraction { // 函数分数 public: Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {} operator double() const { // 转换函数 return (double) (m_numerator / m_denominator) } private: int m_numerator; //分子 int m_denominator; // 分母 }; Fraction f(3, 5); double d = 4 &#43; f; // 调用oper">
<meta itemprop="datePublished" content="2019-05-21T10:25:00+00:00" />
<meta itemprop="dateModified" content="2019-05-21T10:25:00+00:00" />
<meta itemprop="wordCount" content="3625">



<meta itemprop="keywords" content="C&#43;&#43;," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; 面向对象高级编程下-侯捷"/>
<meta name="twitter:description" content="1. Conversion function, 转换函数 class Fraction { // 函数分数 public: Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {} operator double() const { // 转换函数 return (double) (m_numerator / m_denominator) } private: int m_numerator; //分子 int m_denominator; // 分母 }; Fraction f(3, 5); double d = 4 &#43; f; // 调用oper"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">LymanLife</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">LymanLife</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; 面向对象高级编程下-侯捷</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-05-21 </span>
        <div class="post-category">
            <a href="/categories/c&#43;&#43;/"> C&#43;&#43; </a>
            </div>
          <span class="more-meta"> 3625 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#1-conversion-function-转换函数">1. Conversion function, 转换函数</a></li>
            <li><a href="#2-智能指针-pointer-like-classes">2. 智能指针 pointer-like classes</a></li>
            <li><a href="#3-function-like-classes所谓仿函数">3. function like classes,所谓仿函数</a></li>
            <li><a href="#4-命名空间-namespace">4. 命名空间 namespace</a></li>
            <li><a href="#5-template-模板">5. Template, 模板</a></li>
            <li><a href="#5-specialization-模板特化">5. specialization, 模板特化</a></li>
            <li><a href="#6-template-template-parameter-模板模板参数">6. template template parameter, 模板模板参数</a></li>
          </ul>
        </li>
        <li><a href="#二c11">二、C++11</a>
          <ul>
            <li><a href="#1-variadic-templatessince-c11数量不定的模板参数">1. variadic templates(since c++11),数量不定的模板参数</a></li>
            <li><a href="#2-auto">2. auto</a></li>
            <li><a href="#3-ranged-base-for">3. ranged-base for</a></li>
            <li><a href="#4-reference">4. reference</a></li>
          </ul>
        </li>
        <li><a href="#三对象模型object-model">三、对象模型(object model)</a>
          <ul>
            <li><a href="#1-关于vptr虚指针和vtbl虚表">1. 关于vptr(虚指针)和vtbl(虚表)</a></li>
            <li><a href="#2-关于动态绑定dynamic-binding">2. 关于动态绑定(dynamic binding)</a></li>
          </ul>
        </li>
        <li><a href="#四补充">四、补充</a>
          <ul>
            <li><a href="#1-const">1. const</a></li>
            <li><a href="#2关于new和delete">2.关于new和delete</a></li>
            <li><a href="#3-接口示例">3. 接口示例</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h3 id="1-conversion-function-转换函数">1. Conversion function, 转换函数</h3>
<pre><code class="language-CPP">class Fraction {  // 函数分数

public: 
    Fraction(int num, int den = 1)
        : m_numerator(num), m_denominator(den) {}

    operator double() const {  // 转换函数
        return (double) (m_numerator / m_denominator)
    }

private:
    int m_numerator;  //分子
    int m_denominator; // 分母
};

Fraction f(3, 5);
double d = 4 + f; // 调用operator double() 将f转为0.6

</code></pre>
<ul>
<li>没有return type</li>
<li>没有参数</li>
<li>转换不会改变 class 里面的 data,所以要加 const</li>
<li>任何一个Type都能作为转换函数，只要先前声明过，编译器认识</li>
<li>作用：可以把 <strong>这种东西</strong> 转换成 <strong>别的东西</strong></li>
<li>编译器先找 global function operator+()</li>
<li>其次找转化函数 operator double()</li>
</ul>
<h4 id="non-explicit-one-argument-constructor-隐式构造">Non-explicit One Argument Constructor 隐式构造</h4>
<pre><code class="language-CPP">class Fraction {  // 函数分数

public: 
    Fraction(int num, int den = 1)
        : m_numerator(num), m_denominator(den) {}

    Fraction operator+ (const Fraction&amp; f) {
        return Fraction(....);
    }

private:
    int m_numerator;  //分子
    int m_denominator; // 分母
};

Fraction f(3, 5);
Fraction d = 4 + f; // 调用non explicit ctor 将4 转为4/1 然后调用operator+
//方向与上一个方向相反
</code></pre>
<h4 id="3-conversion-function-vs-non-explicit-one-argument-ctor">3. Conversion function vs. Non-explicit One Argument ctor</h4>
<pre><code class="language-CPP">class Fraction {  // 函数分数

public: 
    Fraction(int num, int den = 1)
        : m_numerator(num), m_denominator(den) {}

    operator double() const {  // 转换函数
        return (double) (m_numerator / m_denominator)
    }

    Fraction operator+ (const Fraction&amp; f) {
    return Fraction(....);
    }

private:
    int m_numerator;  //分子
    int m_denominator; // 分母
};

Fraction f(3, 5);
double d = 4 + f;  //可以运行,如1. 
Fraction d = 4 + f; // error 二意,不知道用谁好.
</code></pre>
<p>两种可能的路线:</p>
<ul>
<li>调用 non-explicit ctro 将 4 转为 Fraction，再调用 operator+</li>
<li>调用转换函数 double() 将 f 转为 double，在调用数学的加法，最后把结果通过 non-explicit ctor 转为 Fraction</li>
</ul>
<h4 id="4-explicit-one-argument-ctor">4. explicit one argument ctor</h4>
<pre><code class="language-CPP">class Fraction {  // 函数分数

public: 
    explicit Fraction(int num, int den = 1)
        : m_numerator(num), m_denominator(den) {}

    operator double() const {  // 转换函数
        return (double) (m_numerator / m_denominator)
    }

    Fraction operator+ (const Fraction&amp; f) {
    return Fraction(....);
    }

private:
    int m_numerator;  //分子
    int m_denominator; // 分母
};

Fraction f(3, 5);
Fraction d = 4 + f; // error conversion from 'double' to Fraction
</code></pre>
<h3 id="2-智能指针-pointer-like-classes">2. 智能指针 pointer-like classes</h3>
<pre><code class="language-CPP">template&lt;class T&gt;
class shared_ptr
{
public:
    T&amp; operator* () const
    {
        return *px;
    }
    T* operator-&gt;() const 
    {
        return px;
    }
    shared_ptr(T* p) : px(p) { }  //构造函数,接受天然的指针

private:
    T* px;  //一个指针
    long* pn;
};
</code></pre>
<p>智能指针的使用</p>
<pre><code class="language-CPP">struct Foo
{
    void method(void) { }
};

shared_ptr&lt;Foo&gt; sp(new Foo); // 创建一个智能指针对象sp

Foo f(*sp);     
sp-&gt;method();    // 等于 px-&gt;method();
</code></pre>
<h4 id="pointer-like-classes-位于迭代器">pointer like classes, 位于迭代器</h4>
<blockquote>
<p>主要用途就是遍历容器.</p>
</blockquote>
<pre><code class="language-CPP">    reference operator* () const {
        return (*node).data;
    }
    pointer operator-&gt;() const {
        return &amp;(operator*());
    }

//迭代器的使用
list&lt;Foo&gt;::iterator ite;

*ite;  //获得一个foo object
ite-&gt;method();  // 意思是调用foo::method()
//相当于 (*ite).method();
//相当于(&amp;(*ite))-&gt;method();
</code></pre>
<h3 id="3-function-like-classes所谓仿函数">3. function like classes,所谓仿函数</h3>
<ul>
<li>目的:设计一个class让它的行为想一个函数.</li>
<li>新标准中又称为函数对象 function object</li>
<li>通过重载 <strong>operator()</strong> &mdash; function call operator 实现</li>
<li><strong>为什么需要仿函数？</strong>
<ul>
<li>一般情况下函数指针可以达到“<strong>将整组操作当做算法的参数</strong>”这一目的</li>
<li>但函数指针不能满足 STL 对抽象性的要求，也不能满足软件积木的要求&mdash;函数指正无法和 STL 其他组件搭配，产生更灵活的变化。</li>
<li><strong>是无法定义一个指向模板函数的指针的</strong></li>
</ul>
</li>
<li>用法
<ul>
<li><code>greater&lt;int&gt; ig; ig(4,6);</code></li>
<li>greater<int>()(6,4)` 第一个括号用于产生临时变量，第二个括号用于调用 function call</li>
</ul>
</li>
</ul>
<pre><code class="language-CPP">template &lt;class T&gt;
struct identity {
    const T&amp;
    operator() (const T&amp; x) const { //对这个操作付重载就是仿函数
        return x;
    }
};

template &lt;class Pair&gt;
struct select1st {
    const typename Pair::first_type&amp;
    operator() (const Pair&amp; x) const { return x.first;}
};

template &lt;class Pair&gt;
struct select2st {
    const typename Pair::second_type&amp;
    operator() (const Pair&amp; x) const { return x.second;}
};
</code></pre>
<h3 id="4-命名空间-namespace">4. 命名空间 namespace</h3>
<p>为了防止同名类之间冲突</p>
<pre><code class="language-cpp">using namespace std;
//-----------------------------
#include &lt;iostream&gt;
#include &lt;memory&gt; //shared_ptr
namespace jj01 {
    void test () { }
} // namespace
//-----------------------------
#include &lt;iostream&gt;
#include &lt;list&gt;
namespace jj02 {
    void test () { }
}



int main(int argc, char** argv){
    jjo1::test();
    jj02::test();
}

</code></pre>
<h3 id="5-template-模板">5. Template, 模板</h3>
<h4 id="class-template">class template</h4>
<p>在设计类的时候,把某些类型抽出来,允许使用者任意指定</p>
<pre><code class="language-cpp">
template&lt;typename T&gt;
class complex{
public:
    complex(T x = 0, T i = 0)
        : re(x), im(i){}

    complex&amp; operator += (const complex&amp;);
    T real() const {return re;}
    T imag() const {return im;}

private:
    T re, im;


    friend complex&amp; __doapl (complex*, const complex&amp;);
}
</code></pre>
<h4 id="函数模板-function-template">函数模板 function template</h4>
<p>设计一个函数,它的参数可以是任意类型的参数.</p>
<pre><code class="language-cpp">class stone {
public:
    stone(int w, int h, int we)
        : _w(w), -h(h), _weight(we) { }

    bool operator&lt; (const stone&amp; ths) const {
        return _weight &lt; ths._weight;
    }
private:
    int _w, _h, _weight;
}

template &lt;class T&gt;  // 函数模板
inline
const T&amp; min(const T&amp; a, const T&amp; b){
    return b &lt; a ? b : a;
}

//调用
stone r1(2, 3), r2(3, 3), r3;
r3 = min(r1, r2); 
//直接调用,不用制定类型,因为编译器会推导其类型

</code></pre>
<h4 id="成员模板-member-template">成员模板 member template</h4>
<p>模板类中的模板成员函数</p>
<pre><code class="language-CPP">template &lt;class T1, class T2&gt;
struct pair {
    typedef T1 first_type;
    typedef T1 first_type;

    T1 first;
    T2 second;

    pair()
        :first(T1()), second(T2()) { }
    pair(const T1&amp; a, const T2&amp; b)
        :first(a), second(b) { }
     
    // 成员模板
    template &lt;class U1, clss U2&gt;
    pair(const pair&lt;U1, U2&gt;&amp; p)
        : first(p.first), second(p.second) { }
};
</code></pre>
<ul>
<li>
<p>是模板里的一个 Member，本身又是一个 Template</p>
</li>
<li>
<p>子类对象初始化父类容器</p>
<ul>
<li><img src="http://upload-images.jianshu.io/upload_images/9987091-2ce42a8c46643f54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>把一个由鲫鱼和麻雀构成的 pair，放进(拷贝)一个由鱼类和鸟类构成的 pair 中</li>
</ul>
<pre><code class="language-cpp">pair&lt;Derived1, Derived2&gt; p;
pair&lt;Base1, Base2&gt; p2(p);  // 用子类对象构造的 p 去初始化父类的容器 p2，等价于
==&gt; pair&lt;Base1, Base2&gt; p2(pair&lt;Derived1, Derived2&gt;())
</code></pre>
</li>
</ul>
<h3 id="5-specialization-模板特化">5. specialization, 模板特化</h3>
<p>泛化:特化的反面,就是模板,比如有一个类型用的时候指定类型
特化:一个设计者面对独特的类型要做特殊的设计.</p>
<pre><code class="language-CPP">template &lt;class key&gt; //泛化
struct hash{ };

//特化
template &lt;&gt;
struct hash&lt;char&gt; {
    size_t operator() (char x) const {return x;} //中间的() 表示是一个临时对象
};
template &lt;&gt;
struct hash&lt;int&gt; {
    size_t operator() (char x) const {return x;} 
};
template &lt;&gt;
struct hash&lt;long&gt; {
    size_t operator() (char x) const {return x;} 
}
</code></pre>
<h4 id="partial-specialzation-模板偏特化">partial specialzation, 模板偏特化</h4>
<p>从两个角度来讲,一是个数上的偏,另一是范围上的偏.</p>
<ul>
<li>个数上的偏特化</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T, typename Alloc = ...&gt; // 模板参数.alloc为分配器
class vector {

};
//绑定
template &lt;typename Alloc = ...&gt; //两个参数变为一个参数,
class vector &lt;bool, Alloc&gt; {    //直接给出一个bool参数,不用泛化参数.

};
</code></pre>
<ul>
<li>范围上的偏特化</li>
</ul>
<pre><code class="language-cpp">template&lt;typename T&gt;    // 泛化
class C {

};

template&lt;typename U&gt; //偏特化版本, 当用指针时,用这个版本
calss C&lt;U*&gt; {

}

//运用
C&lt;string&gt; obj1;
C&lt;string*&gt; obj1;
</code></pre>
<h3 id="6-template-template-parameter-模板模板参数">6. template template parameter, 模板模板参数</h3>
<pre><code class="language-cpp">template&lt;typename T, 
            template &lt;typename T&gt;
                    class Container
        &gt;
class XCls {
private:
    Container&lt;T&gt; c; //用第一个模板参数做container参数
public:

};

template &lt;typename T&gt;
using Lst = list&lt;T, allocator&lt;T&gt;&gt;;

//example
XCls&lt;string, list&gt; mylst1; //错误,编译过不了,必须使用上面的using Lst
XCls&lt;string, Lst&gt; mylst2;  // ok
</code></pre>
<pre><code class="language-cpp">template&lt;typename T, 
            template &lt;typename T&gt;
                    class SmartPtr  //不适用容器,而是使用智能指针
        &gt;
class XCls {
private:
    SmartPtr&lt;T&gt; sp; //用第一个模板参数做SmartPtr参数
public:
    XCls() : sp(new T) { }
};

//example
XCls&lt;string, shared_ptr&gt; p1;
XCls&lt;long, auto_ptr&gt; p1;

</code></pre>
<h2 id="二c11">二、C++11</h2>
<p><img src="http://upload-images.jianshu.io/upload_images/9987091-fed95f831ca75122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="1-variadic-templatessince-c11数量不定的模板参数">1. variadic templates(since c++11),数量不定的模板参数</h3>
<pre><code class="language-cpp">void print() {} //最后零个参数,调用这个函数

template&lt;typename T, typename... Types&gt;
void print(const T&amp; firstArg, const Types&amp;... args){
    cout &lt;&lt; firstArg &lt;&lt; endl;
    print(args...);   //递归的调用自己
}

// 调用
print(7.5, &quot;hello&quot;, bitset&lt;16&gt;(377), 42);//每次调用print,分为一个和其他
</code></pre>
<p>&hellip;就是一个所谓的pack(包),可以用sizeof&hellip;(args)得到具体的数量
用于template parameters,就是template parameters pack(模板参数包)
用于function parameters types,就是function parameters types pack(函数参数类型包)
用于function parameters,就是function parameters pack(函数参数包)</p>
<h3 id="2-auto">2. auto</h3>
<pre><code class="language-cpp">list&lt;string&gt; c;

list&lt;string&gt;::iterator ite;
ite = find(c.begin(), c.end(), target);

auto ite = find(c.begin(), c.end(), target);  //让编译器自己去推
</code></pre>
<h3 id="3-ranged-base-for">3. ranged-base for</h3>
<p>//dec1 变量,,coll 容器,,从右边的容器中每个元素赋值给dec1
for(dec1 : coll) {
statement
}</p>
<pre><code class="language-cpp">vector&lt;double&gt; vec(10);

for(auto elem : vec) {      //pass by value
    cout &lt;&lt; elem &lt;&lt;endl;
}
for(auto&amp; elem : vec) {     //pass by reference
    elem *= 3;
}
</code></pre>
<p><img src="http://upload-images.jianshu.io/upload_images/9987091-a4e3eceec176ff66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="4-reference">4. reference</h3>
<blockquote>
<p>引用就是指针，一种 <strong>漂亮</strong> 的指针</p>
</blockquote>
<pre><code class="language-cpp">int x = 0;
int* p = &amp;x;    //p is a pointer to x
int&amp; r = x;     //r is a reference to x,意思为r代表x;
int x2 = 5;

r = x2;         //r不能重新代表其他变量,现在r, x 都是5;
int&amp; r2 = r;    //现在r2 = 5

常见用途:多数用在参数的处理上,而不是声明变量.
void func1(Cls* pobj) {pobj-&gt;xxx();}
void func2(Cls obj) {obj.xxx();}
void func3(Cls&amp; obj) {obj.xxx();}

//调用端
Cls obj;
func1(&amp;obj);   //接口不同
func2(obj);    //调用端接口和reference一样
func3(obj);    //调用端接口和传值一样,但是比它快.
</code></pre>
<p><img src="http://upload-images.jianshu.io/upload_images/9987091-7dd356b4328aa0f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>应该注意的地方</strong></p>
<ul>
<li>引用在声明时一定要有<strong>初值</strong></li>
<li>赋值后其值不能再变改变</li>
<li>reference 本质上只占 4 byte(32位系统), 但 sizeof(x) == sizeof(r)</li>
<li>&amp;x == &amp;r</li>
<li>reference 通常不用于声明变量，而用于 <em>参数类型(parameters type)</em> 和 <em>返回类型(return type)</em> 的描述</li>
<li>引用和值被视为同意中函数签名，因此不能只有两者不同时不能用于函数重载</li>
</ul>
<pre><code class="language-cpp">double imag(const double&amp; im) { .... }
double imag(const double  im) { .... } // Ambiguity
</code></pre>
<blockquote>
<p>const 是函数签名的一部分 <code>double imga() {}</code> 和 <code>double imga() const {}</code> 是两个不同的函数</p>
</blockquote>
<h2 id="三对象模型object-model">三、对象模型(object model)</h2>
<h3 id="1-关于vptr虚指针和vtbl虚表">1. 关于vptr(虚指针)和vtbl(虚表)</h3>
<pre><code class="language-cpp">class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
class B:public A {
public:
    virtual void vfunc1();
    void func2();
private:
    int m_data3;
};
class C:public B {
public:
    virtual void vfunc1();
    void func2();
private:
    int m_data4;
}
</code></pre>
<p>在一个类中,只要有虚函数那就有一个4字节的虚指针(无论多少个虚函数都只有一个)
虚指针指向一个虚表,虚表中有指针指向对应的虚函数.如下图所示,当虚函数没有改写被继承时,不同类中的相同虚函数指向同一个函数,发生改写时指向不同的函数.
<img src="http://upload-images.jianshu.io/upload_images/9987091-0b12bf7909f67526.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240%22%E8%99%9A%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E8%A1%A8%E7%9A%84%E6%8C%87%E5%90%91%22" alt="继承关系中的虚函数"></p>
<ul>
<li>vptr &mdash; 虚指针，指向虚表 vtbl, 一个类中只要有虚函数，就会有一个 vptr
<ul>
<li>函数继承的是调用权，父类有虚函数，子类一定就也有</li>
</ul>
</li>
<li>vtbl &mdash; 虚表，存放所有虚函数的函数指针（地址）</li>
<li>C 语法：<code>(*(p-&gt;vptr)[n])(p); or  (* p-&gt;vptr[n] )(p);</code></li>
<li><strong>动态绑定三要素</strong>
<ul>
<li>函数通过指针调用</li>
<li>指针向上转型 <strong>up-cast</strong> &mdash; <code>A* p = new B(); // 父类指针指向子类对象</code></li>
<li>调用的是 **虚函数</li>
</ul>
</li>
</ul>
<h4 id="多态">多态</h4>
<p><img src="http://upload-images.jianshu.io/upload_images/9987091-adfa8ec4b412697b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><code>list&lt;A*&gt; myLst;</code> 通过父类指针容器存放不同的子类对象</li>
<li>通过指针指向对象的不同调用不一样的 draw() 函数</li>
<li>若用 C 来实现多态，一是写起来麻烦，需要判断指针指向的对象类型来调用不一样的 draw() 函数；二是缺乏扩展性，未来新增子类时还需重新更改判断的代码。</li>
</ul>
<h4 id="关于this">关于this</h4>
<ul>
<li>通过一个对象来调用一个函数,对象的地址就是this</li>
<li>下图为虚函数的<strong>template method</strong>用法用来解释this指针的走向</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9987091-32b1212be4e60bd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="this走向"></p>
<h3 id="2-关于动态绑定dynamic-binding">2. 关于动态绑定(dynamic binding)</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/9987091-19ee87c7813e85c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240%22%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A1%22" alt="动态绑定1"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9987091-e251c0ff917c09b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240%22%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A2%22" alt="动态绑定2"></p>
<ul>
<li><code>a.vfunc1()</code> 属于静态绑定，调用是 <code>A::vfunc1()</code> 利用对象调用，不满足动态绑定的要求，对象是谁，调用的就是谁的方法</li>
<li><code>pa-&gt;vfunc1() ==&gt; call dword ptr [edx]</code> 即是 <code>(*(p-&gt;vptr)[n])(p)</code></li>
</ul>
<h2 id="四补充">四、补充</h2>
<h3 id="1-const">1. const</h3>
<ul>
<li>const member functions 常量成员函数
<ul>
<li><code>const </code>加在 () 和 {} 之间 <code>double real () const { return re; }</code></li>
<li>函数加上 const, 是告诉编译器该成员函数不会改变 class 的 data</li>
<li>只有成员函数有 const, 一般全局函数没有 const</li>
</ul>
</li>
<li>在函数的参数列的后面意思为不打算改变class的数据,但是只能放在成员函数的后面,不可以放在全局函数中.如下图所示.</li>
</ul>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E8%B0%88%E8%B0%88const.png" alt="const2"></p>
<ul>
<li>当成员函数的 const 和 non-const 版本同时存在时
<ul>
<li><strong>const</strong> object 只能调用 const 版本</li>
<li>non-cosnt object 只能调用 non-const 版本</li>
</ul>
</li>
</ul>
<h3 id="2关于new和delete">2.关于new和delete</h3>
<p>对于全局new和delete做重载
<img src="https://gile.oss-cn-shanghai.aliyuncs.com/c%2B%2B11/new%20and%20delete.png" alt="const"></p>
<p>class中做重载,接管全局的new和delete,用来做内存池</p>
<h3 id="3-接口示例">3. 接口示例</h3>
<pre><code class="language-cpp">class Foo {
    int _id;
    long _data;
    string _str;

public:
    Foo():_id(0)  {cout &lt;&lt; &quot;default ctor.this=&quot; &lt;&lt; this &lt;&lt; &quot;id=&quot; &lt;&lt; _id}
    Foo(int i):_id(i)  {cout &lt;&lt; &quot;ctor.this=&quot; &lt;&lt; this &lt;&lt; &quot;id=&quot; &lt;&lt; _id}
//virtual
    ~Foo()  {cout &lt;&lt; &quot;dtor.this=&quot; &lt;&lt; this &lt;&lt; &quot;id=&quot; &lt;&lt; _id &lt;&lt; endl;}
    static void* operator new(size_t size);
    static void operator delete(void* pdead, size_t size);
    static void* operator new[](size_t size);
    static void operator delete[](void* pdead, size_t size);
}

void* Foo::operator new(size_t size) {
    Foo* p = (Foo*)malloc(size);
    cout &lt;&lt; ....
    return p;
}
void* Foo::operator delete(void* pdead, size_t size) {
    cout &lt;&lt; ..
    free(pdead);
}

void* Foo::operator new[](size_t size) {
    Foo* p = (Foo*)malloc(size);
    cout &lt;&lt; ....
    return p;
}
void* Foo::operator delete(void* pdead, size_t size) {
    cout &lt;&lt; ..
    free(pdead);
}

Foo* pf = new Foo;      //若五members就调用globals
delete pf;

//强制使用global new and delete
Foo* pf = ::new Foo;
</code></pre>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/stl%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8Bgp/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">「STL」与泛型编程（GP）</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B8%8A-%E4%BE%AF%E6%8D%B7/">
            <span class="next-text nav-default">C&#43;&#43; 面向对象高级编程上-侯捷</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="lyman0522@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
  <a href="http://lyman.fun/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>lyman</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
