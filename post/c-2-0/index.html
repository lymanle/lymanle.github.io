<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; 11 新特性 - LymanLife</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="lyman" /><meta name="description" content="目标: 较全面的认识c&#43;&#43; 2.0 新特性. 2.0的新特性包括语言和标准库两个层面 一. 语言部分 1. Variadic Template 数量不定的模板参数 void print() { // 最后调用的print } template&amp;lt;typename" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.78.2 with theme even" />


<link rel="canonical" href="http://lyman.fun/post/c-2-0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; 11 新特性" />
<meta property="og:description" content="目标: 较全面的认识c&#43;&#43; 2.0 新特性. 2.0的新特性包括语言和标准库两个层面 一. 语言部分 1. Variadic Template 数量不定的模板参数 void print() { // 最后调用的print } template&lt;typename" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://lyman.fun/post/c-2-0/" />
<meta property="article:published_time" content="2019-06-27T22:18:25+00:00" />
<meta property="article:modified_time" content="2019-06-27T22:18:25+00:00" />
<meta itemprop="name" content="C&#43;&#43; 11 新特性">
<meta itemprop="description" content="目标: 较全面的认识c&#43;&#43; 2.0 新特性. 2.0的新特性包括语言和标准库两个层面 一. 语言部分 1. Variadic Template 数量不定的模板参数 void print() { // 最后调用的print } template&lt;typename">
<meta itemprop="datePublished" content="2019-06-27T22:18:25+00:00" />
<meta itemprop="dateModified" content="2019-06-27T22:18:25+00:00" />
<meta itemprop="wordCount" content="4961">



<meta itemprop="keywords" content="C&#43;&#43;," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; 11 新特性"/>
<meta name="twitter:description" content="目标: 较全面的认识c&#43;&#43; 2.0 新特性. 2.0的新特性包括语言和标准库两个层面 一. 语言部分 1. Variadic Template 数量不定的模板参数 void print() { // 最后调用的print } template&lt;typename"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">LymanLife</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">LymanLife</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; 11 新特性</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-06-27 </span>
        <div class="post-category">
            <a href="/categories/c&#43;&#43;/"> C&#43;&#43; </a>
            </div>
          <span class="more-meta"> 4961 words </span>
          <span class="more-meta"> 10 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#一--语言部分">一.  语言部分</a></li>
            <li><a href="#二-标准库部分">二. 标准库部分</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p>目标: 较全面的认识c++ 2.0 新特性.</p>
</blockquote>
<p>2.0的新特性包括语言和标准库两个层面</p>
<h3 id="一--语言部分">一.  语言部分</h3>
<h4 id="1-variadic-template">1. Variadic Template</h4>
<p>数量不定的模板参数</p>
<pre><code class="language-cpp">void print() { // 最后调用的print
    
}

template&lt;typename T, typename... Types&gt; //可以帮我们做递归
void print(const T&amp; firstArg, const Types&amp;... atgs){
	cout &lt;&lt; firstArg &lt;&lt; endl;
	print(args...);
}

//for example
print(7.5, &quot;hello&quot;, bitset&lt;16&gt;(377), 42); //递归的调用自身输出
</code></pre>
<p>在variadic templates中,sizeof&hellip;(args) 可以得到参数的数量</p>
<pre><code class="language-cpp">template&lt;typename... Types&gt; 
void print(const Types&amp;... atgs){
	//...
}
</code></pre>
<p>以上的代码可以和上面两个print并存.</p>
<p>tuple的实现:</p>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/c%2B%2B11/tuple%E5%AE%9E%E7%8E%B0.png" alt="tuple"></p>
<h4 id="2-spaces-in-template-expressions">2. spaces in template expressions</h4>
<p>在新标准中不要求两个相邻的template加入空格</p>
<pre><code class="language-cpp">vector&lt;list&lt;int&gt; &gt;;	//ok in each c++ version
vector&lt;list&lt;int&gt;&gt;;  //ok in c++ 11
</code></pre>
<h4 id="3-nullptr-and-stdnullptr_t">3. nullptr and std::nullptr_t</h4>
<p>c++11 可以使用nullptr 取代0 或者NULL</p>
<pre><code class="language-cpp">void f(int);
void f(void*);
f(0);	//调用f(int)
f(NULL);	//调用(int) if NULL is 0, ambiguous otherwise
f(nullptr)
</code></pre>
<h4 id="4-automatic-type-deduction-with-auto">4. Automatic Type Deduction with auto</h4>
<pre><code class="language-cpp">auto i= 42; //i 是int类型
double f();
auto d= f(); //d 是double类型
</code></pre>
<p>主要用于type很长或者很复杂的地方</p>
<pre><code class="language-cpp">vector&lt;string&gt; v;
auto pos = v.begin();  //pos = vector&lt;string&gt;::iterator

// l has the type of a lambda taking an int and returning a bool
auto l = [](int x) -&gt; bool {	
    ...
};  //l 是一个object 用来表示lambda
</code></pre>
<h4 id="5-uniform-initialization">5. Uniform Initialization</h4>
<p>早期,一些新手很困惑如何初始化一个变量或者对象,初始化可能是{}, (), = 等形式</p>
<p>C++11中,可以只有大括号{}</p>
<pre><code class="language-pp">int values[] {1,2,3];
vector&lt;int&gt; v{1, 3, 4, 5, 6};
</code></pre>
<p>编译器只要看到{} 就会做出一个initializer_list<T>, 它的内部有一个array&lt;T, n&gt;, 调用ctor时, 该array内的元素可被编译器逐一分解传给函数. 但是当函数的参数本身就是一个initializer_list<T>时,调用者不能给予数个T参数然后以为她们会自动被转为一个initializer_list<T>传入,而是直接传入initializer_list<T></p>
<h4 id="6-initializer_list">6. initializer_list&lt;&gt;</h4>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/c%2B%2B11/initializer_list.png" alt="initializer_list的使用"></p>
<p>如果一个函数有两个版本,看情况调用.如下图</p>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/c%2B%2B11/initializer_list_1.png" alt="加了{}版本会自动调用initiaerlist"></p>
<h4 id="7-explicit-for-ctors-taking-more-than-one-argument">7. explicit for ctors taking more than one argument</h4>
<p>指定构造函数或转换函数 (C++11 起)为显式，即它不能用于<a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">隐式转换</a>和<a href="https://zh.cppreference.com/w/cpp/language/copy_initialization">复制初始化</a>。</p>
<pre><code class="language-cpp">class p {
public:
    p(int a, int b){
        cout &lt;&lt; &quot;p(int a, int b) \n&quot;;
    }
   
    p(initializer_list&lt;int&gt;){
        cout &lt;&lt; &quot;p(initializer_list&lt;int&gt;) \n&quot;;
    }
    
    explicit p(int a, int b, int c) {
        cout &lt;&lt; &quot;explict p \n&quot;
    }
    
};

void fp(const p&amp;) {  };
</code></pre>
<h4 id="8-range-based-for-statement">8. range-based for statement</h4>
<pre><code class="language-cpp">for( dec1 : coll ) {
    statement
}


vector&lt;double&gt; vec;
...
for(auto elem : evc) {
    cout &lt;&lt; elelm &lt;&lt; endl;
}

for(auto&amp; elem : evc) {
    elem *= 3;
}
</code></pre>
<p>range-based for statement 内部实现:</p>
<pre><code class="language-cpp">for(decl : coll){
    statement
}
//============&gt;&gt;
for( auto _pos = coll.begin(), _end = coll.end(); _pos!= _end; ++_pos) {
    decl =* _pos;
    statement
}
</code></pre>
<p>no explicit type conversion are possible when elements are initializer sa decl inside the for loop.</p>
<p>Thus, the following does not compile; 意思就是类型转换出错.需要查看源头是否需要显式的转换</p>
<pre><code class="language-cpp">class C {
    public:
    	explicit C(const string&amp; s); // explicit(!)type consersion from strings
    	...
};

vector&lt;string&gt; vs;
for(const C&amp; elem : vs){	//error, no conversion from strings
    cout &lt;&lt; elem &lt;&lt; endl;
}
</code></pre>
<h4 id="9-default--delete">9. =default, = delete</h4>
<p>如果自行定义了一个ctor,编译器就不会再给你一个default ctor.</p>
<p>如果强行加上 =default, 就可以重新获得并使用default ctor.</p>
<pre><code class="language-cpp">class Zoo {
public:
	ZOo(int i1, int i2) : de(i1), d2(i2) {} 
    ZOo(const Zoo&amp;) = delete;   //不要拷贝构造
    ZOo(Zoo&amp;&amp;) = default; 	//右值引用move
    ZOo&amp; operator = (const Zoo&amp;) = default; 	//拷贝赋值
    ZOo&amp; operator = (const Zoo&amp;&amp;) = delete; 	//不要
    
    virtual ~Zoo() { }
private:
    int d1, d2;
};
</code></pre>
<p>复习c++知识: 如果一个空的class ,c++处理它之后,编译器会为他声明一个 copy ctor, copy assignment operator , dtor (<strong>所谓的big-three</strong>),如果你没有声明任何ctor,编译器也会为你声明一个default ctor.</p>
<p>目的是,这些类如果当父类被继承时候,需要用到这些</p>
<pre><code class="language-cpp">class Empty() {};
//==========&gt;
class Empty() {
public:
    Empty() {...}
    Empty(const Empty&amp; rhs){...}
    ~Empty() {...}
    
    Empty&amp; operator=(const Empty&amp; ths) {...}
};
</code></pre>
<p>要给类如果不包含指针,只用默认的就可以了,如果包含指针,指针本身有浅拷贝和深拷贝区别,所以必须要自己实现自己的big three</p>
<p>设计自己的class的权限</p>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/c%2B%2B11/no-copy.png" alt="限制类型"></p>
<h4 id="10-alias-templatetemplate-typedef-化名">10. Alias Template(template typedef) 化名</h4>
<pre><code class="language-cpp">template &lt;typename T&gt;
using Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;; 
//the term 
Vec&lt;int&gt; coll;
//is equivalent to
std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll;
</code></pre>
<p>使用macro(define, typedef)无法达到同样的效果,using可以指定参数</p>
<p><strong>使用function template + iterator + traits</strong></p>
<pre><code class="language-cpp">//设计一个test_move函数,传入一个容器,一个类型,然后测试这个容器是否支持move操作
template&lt;typename Container&gt;
void test_moveable(Container c) {
typedef typename iterator_traits&lt;typename Container::iterator&gt;::value_type Valtype;
	for(long i = 0; i &lt; SIZE; ++i){
		c.insert(c.end(), Valtype());
	}
	
	Container c1(c);
	Container c2(std::move(c));
	c1.swap(c2);
}
//使用
test_moveable(list&lt;MyString&gt;());
</code></pre>
<p>但是如果没有type_traits时候,我们应该咋办呢例如我只想要传入一个vector<string> 然后想拿到string</p>
<p>这里就用到了template template .</p>
<h4 id="11-template-template-parameter">11. template template parameter</h4>
<pre><code class="language-cpp">template&lt;typename T, template&lt;class&gt; class Container&gt;
class XCls {
private:
	Container&lt;T&gt; c;
public:
	XCls() {
		for(long i = 0; i &lt; SIZE; ++i){
			c.insert(c.end(), Valtype());
		}
	
		Container c1(c);
		Container c2(std::move(c));
		c1.swap(c2);
	}
}
</code></pre>
<p>这样还是会报错,因为vector,list等容器需要两个参数</p>
<p>这里就需要用到了using</p>
<p><strong>template template parameter + alias template</strong></p>
<pre><code class="language-cpp">template&lt;typename T&gt;
using Vec = vector&lt;T, allocator&lt;T&gt;&gt;;

template&lt;typename T&gt;
using Lst = list&lt;T, allocator&lt;T&gt;&gt;;

template&lt;typename T&gt;
using Deq = deque&lt;T, allocator&lt;T&gt;&gt;;

//使用
XCls&lt;MyString, Vec&gt; c1;
XCls&lt;MyStringNoMove, Vec&gt; c1;
</code></pre>
<h4 id="12-type-aliassimilar-to-typedef">12. Type Alias(similar to typedef)</h4>
<pre><code class="language-cpp">type alias, identical to
//typedef void(*func)(int, int);	//意思是func是一个函数指针,两个参数
using func = void(*func) (int, int);//等于上一行

//the name &quot;func&quot; now denotes a pointer to function;
void example(int, int){}
func fn = example;
</code></pre>
<p>第二种</p>
<pre><code class="language-cpp">//type alias used to hide a template parameter
template&lt;class CharT&gt; using mystring = 
    std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;&gt;;

mustring&lt;char&gt; str;
</code></pre>
<p><strong>using 的其他作用</strong></p>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/using.png" alt="using 其他作用"></p>
<h4 id="13-noexcept">13. noexcept</h4>
<p>如果一个程序一直没有处理异常,这个函数就会throws, 最后calling std::terminate(), which by default calls  std::abort()</p>
<p>用法:</p>
<pre><code class="language-cpp">void foo() noexcept;//意思,保证这个函数不会丢出异常
//====&gt;&gt;
void foo() noexcept(true); //这个函数在一定的条件下不会丢出异常

//for example
void swqp(Type&amp; x, Type&amp; y) noexcept(noexcept(x.swap(y))){
    x.swap(y);
}
</code></pre>
<p>如何让vector强制使用move ctor ,在vector grow时候</p>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/c%2B%2B11/noexpect.png" alt="vector grow inform c++"></p>
<h4 id="14-override-重写">14. override 重写</h4>
<p>如果在override过程中写错了函数名,c++不会通知作者,加了override关键字后,c++会报错</p>
<pre><code class="language-cpp">struct Base {
    virtual void vfunc(float){ }
};
struct Derived1 : Base {
    virtual void vfunc(int){ }
    // 意外的创建了一个新的虚函数
};

struct Derived2 : Base {
    virtual void vfunc(int) override { }
    // 错误,,,这里编译器会提示
    
    virtual void vfunc(float) override {}
    //正确
};
</code></pre>
<h4 id="15-final">15. final</h4>
<p>加了final关键字,子类不再可改写函数</p>
<pre><code class="language-cpp">struct Base1 final {};

struct Derived1 : Base1 {};
//[error]不可以继承final 类
</code></pre>
<pre><code class="language-cpp">struct Base2 final {
    virtual void f() final;
};

struct Derived2 : Base2 {
    void f();
    //[error] overriding final function 'virtual void Base2::f()'
};
</code></pre>
<h4 id="16-decltype">16. decltype</h4>
<p>在c++ primer中有讲到,用来推一个表达式的类型</p>
<ul>
<li>By using the new <strong>decltype</strong> keyword, you can let the compiler find out the type of an expression. This is the realization of the often requested typeof feature. However, the existing typeof implementations were inconsistent and incomplete, so C++ 11 introduced a new keyword. For example:</li>
</ul>
<p>三种应用:</p>
<ul>
<li>
<p>declare return types</p>
<ul>
<li>But with C++ 11, you can alternatively declare the return type of a function behind the parameter list</li>
</ul>
<pre><code class="language-cpp">template&lt;typename T1, typename T2&gt;
auto add(T1 x, T2 y)-&gt;decltype(x+y);
</code></pre>
</li>
<li>
<p>use in metaprogrramming</p>
</li>
<li>
<p>pass the type of a lambda</p>
</li>
</ul>
<pre><code class="language-cpp">auto cmp = [] (const Person&amp; pl, const Person&amp; p2) {
    return pl.lastname()&lt;p2.lastname() ||
        (pl .lastname()==p2.lastnameO&amp;&amp;
         pl .firstname()&lt;p2.firstnameO));
};

std: :set&lt;Person,decltype(cmp)&gt; coll(cinp);
</code></pre>
<p>面封lambda, 我侗手上往往只有object, 没有type 要瘦得其type就得借助於decltype</p>
<h4 id="17-lambdas">17. Lambdas</h4>
<p>c++ 11 中,lambda是一个inline functionality,可以被当作一个参数或local object.</p>
<pre><code class="language-cpp">//for example
auto I = [] {
    std::cout &lt;&lt; &quot;hello lambda&quot; &lt;&lt; std::endl;
}
//shiyong 
I();	//prints &quot;hello lambda&quot;
</code></pre>
<p>具体使用原则:</p>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/c%2B%2B11/lambda.png" alt="lambda"></p>
<p>用decltype推导lambda 类型用来定义一个容器,需要传入这个lambda用作构造</p>
<pre><code class="language-cpp">auto cmp = [](const Person&amp; p1, const Person&amp; p2) {
    return p1.lastname()&lt;p2.lastname() ||
        	(p1.lastname() == p2.lastname() &amp;&amp; 
            p1.firstname()&lt;p2.firstname());
};

std::set&lt;Person, decltype(cmp)&gt; coll(cmp);// 传入一个lambdau对象类型作为排序准则
</code></pre>
<h4 id="18-variadic-template">18. Variadic Template</h4>
<ul>
<li>讲的是template
<ul>
<li>function template</li>
<li>class template</li>
</ul>
</li>
<li>变化的是 template parameters
<ul>
<li>参数个数 : 利用参数个数逐一递减的特性实现递归函数的调用, 使用function template完成</li>
<li>参数类型 : 利用参数个数逐个递减导致参数类型逐个递减实现递归继承或递归复合,以class template实现</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">//例1
void printX(){
    //零个参数时候的处理
}
template &lt;typename T, typename... types&gt;
void printX(const T&amp; firstArg, const types&amp;... args){
	cout &lt;&lt; firstArg &lt;&lt; endl;	//处理第一个参数
	printX(args...); 	//call printX() for remaining arguments
}
</code></pre>
<pre><code class="language-cpp">//例2 使用cariadic template 重写printf()
int* pi = new int;
printf(&quot;%d%s%p%f\n&quot;, 15, &quot;this is ace&quot;, pi, 3.1415926);
//实现
template&lt;typename T, typename... Args&gt;
void printf(const char* s, T value, Args... args){
	while(*S){
		if(*s=='%'&amp;&amp;*(++S)!='%'){
			std::cout &lt;&lt; value;
			printf(++s, args...);//call even when *s == 0 to detect extra 
			return;
		}
		std::cout &lt;&lt; *s++;
	}
	throw std::logic_error(&quot;extra arguments provided to printf&quot;);
}

void printf(const char* s){
	while(*s){
		if(*s=='%'&amp;&amp;*(++S)!='%'){
			throw std::runtime_error(&quot;invalid fomat string;&quot;)
		}
		std::cout &lt;&lt; *s++;
	}
}

</code></pre>
<pre><code class="language-cpp">//例3 一个函数判断一堆数据中最大的数
//当参数的types都相同,用initializer_list足够
</code></pre>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/c%2B%2B11/%E4%BE%8B3.png" alt="例3"></p>
<pre><code class="language-cpp">//4 
cout &lt;&lt; maximum(57, 48, 60, 100, 20, 18) &lt;&lt; endl;

int maximum(int n){
    return n;
}
//利用不断调用std::max() 而完成最大值之获取,其实std::max()已经可以接受任意参数
template&lt;typename... Args&gt;
int maximum(int a, Args... args){
	return std::max(n, maximum(args...));
}
</code></pre>
<pre><code class="language-cpp">//5 以不同的方式处理first元素和last元素,所以我们必须要知道处理元素的index 本例用sizeof...()
cout &lt;&lt; make_tuple(7.5, string(&quot;hello&quot;), bitset&lt;16&gt;(377), 42);
//这里需要重载 operator&lt;&lt; 
//output operator for tuples
template&lt;typename... Args&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const tuple&lt;Args...&gt;&amp; t){
	os &lt;&lt; &quot;[&quot;;
		PRINT_TUPLE&lt;0, sizeof...(Args), Args...&gt;::print(os, t);
	return os &lt;&lt; &quot;]&quot;;
}

// get&lt;IDX&gt; 是tuple一个获取函数
template&lt;int IDX, int MAX, typename... Args&gt;
struct PRINT_TUPLE {	//一个class 递归的创建
	static void print(ostream&amp; os, const tuple&lt;Args...&gt;&amp; t){
		os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX+1==MAX ? &quot;&quot; : &quot;,&quot;);//如果是最后一个元素,不打印,
		PRINT_TUPLE&lt;IDX+1, MAX, Args...&gt;::print(os, t); //递归的调用自己
	}
};

template&lt;int MAX, typename... Args&gt;//处理完毕
struct PRINT_TUPLE&lt;MAX, MAX, Args...&gt; {
	static void print(std::ostream&amp; os, const tuple&lt;Args...&gt;&amp; t){
	
	}
}
</code></pre>
<pre><code class="language-cpp">//6递归的继承
//递归调用处理的是参数,使用function template
//递归继承,处理的是类型(type)使用class template
template&lt;typename... Values&gt; class tuple;
template&lt;&gt; class tuple&lt;&gt; {};
</code></pre>
<pre><code class="language-cpp">template&lt;typename Head, typename... Tail&gt;
class tuple&lt;Head, Tail...&gt; : private tuple&lt;Tail...&gt;{//递归的继承
	typedef tuple&lt;Tail...&gt; inherited
public:
	tuple(){}
	//构造函数,第一个设置head, 第二个调用父类的构造函数
	tuple(Head v, Tail... vtail) : m_head(v), inherited(vtail...){}
	
	typename Head::type Head() {return m_head;}
	inherited&amp; tail(){return *this;}
protected:
	Head m_head;
};

//理解: 继承选用private 
</code></pre>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/c%2B%2B11/%E4%BE%8B6.png" alt="例6 tuple的实现"></p>
<p><strong>编译的时候出错</strong>: typename Head::type head() {return m_head;} //这里编译不过</p>
<p>在本例中tuple&lt;int, float, string&gt; 进去,然后 <strong>Head::type, int</strong>是无法回答的, 所以这里应该使用的是decltype</p>
<p>auto head()-&gt;decltype(m_head){return m_head},</p>
<pre><code class="language-cpp">//正确的版本
template&lt;typename Head, typename... Tail&gt;
class tuple&lt;Head, Tail...&gt; : private tuple&lt;Tail...&gt;{//递归的继承
	typedef tuple&lt;Tail...&gt; inherited
protected:
	Head m_head;	//这里需要移上来,否则编译器说不认得m_head
public:
	tuple(){}
	//构造函数,第一个设置head, 第二个调用父类的构造函数
	tuple(Head v, Tail... vtail) : m_head(v), inherited(vtail...){}
	
	auto head()-&gt;decltype(m_head) {return m_head;}//第一种方案
	Head head() {return m_head;}	//第二种方案,都是可以的,因为我们知道head类型啊,,,哈哈哈
	inherited&amp; tail(){return *this;}
};
</code></pre>
<pre><code class="language-cpp">//例7  递归的复合
template&lt;typename... Values&gt; class tup;
template&lt;&gt; class tup&lt;&gt; {};
//=============================================

template&lt;typename Head, typename... Tail&gt;
class tuple&lt;Head, Tail...&gt; {

	typedef tup&lt;Tail...&gt; composited
protected:
	composited m_tail;
	Head m_head;	//这里需要移上来,否则编译器说不认得m_head
public:
	tup(){}
	//构造函数,第一个设置head, 第二个调用父类的构造函数
	tup(Head v, Tail... vtail) : m_head(v), m_tail(vtail...){}
	
	Head head() {return m_head;}	//函数,取得head
	composited&amp; tail(){return m_tail;}	//函数, 取得tail的引用
};
</code></pre>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/c%2B%2B11/%E4%BE%8B7.png" alt="例7"></p>
<h3 id="二-标准库部分">二. 标准库部分</h3>
<h4 id="1-rvalue-references-右值引用">1. Rvalue references 右值引用</h4>
<blockquote>
<p>右值引用是一种新的引用类型,可以帮助解决<strong>不必要的copying 和 enable perfect forwarding</strong></p>
<p>当赋值的右边是一个右值, 那么左手边的object可以去偷它的resources 而不是 去执行一个allocation</p>
</blockquote>
<ul>
<li><strong>左值</strong>: 左值就是一个变量, 可以出现在operator= 的左边</li>
<li><strong>右值</strong>: 只能出现在operator= 右边;</li>
</ul>
<pre><code class="language-cpp">//用复数实验
complex&lt;int&gt; c1(3, 8), c2(1, 0);
c1 + c2 = complex&lt;int&gt;(4, 9);	//可以当左值
cout &lt;&lt; &quot;c1:&quot; &lt;&lt; c1 &lt;&lt; endl; // 3.8
cout &lt;&lt; &quot;c2:&quot; &lt;&lt; c2 &lt;&lt; endl;	//1.0
complex&lt;int&gt;() = complex&lt;int&gt;(4, 9);	//也可以对临时对象赋值
</code></pre>
<pre><code class="language-cpp">//string 实验
string s1(&quot;hello&quot;);
string s2(&quot;world&quot;);
s1 + s2 = s2;	//竟然可以编译通过
cout &lt;&lt; &quot;s1:&quot; &lt;&lt; s1 &lt;&lt; endl; //hello
cout &lt;&lt; &quot;s2:&quot; &lt;&lt; s2 &lt;&lt; endl;	//world
string() = &quot;world&quot;;	//可以对temp obj赋值, 临时对象是一个右值
</code></pre>
<pre><code class="language-cpp">int foo() {return 5;}

int x = foo(); //ok
int *p = &amp;foo(); //error
foo() = 7; //error
</code></pre>
<p>当右值出现在operator= 的右边, 我们认为对其资源进行偷取/搬移(move)而非拷贝是可以的是合理的</p>
<h4 id="rvalue-references-and-move-semantics">Rvalue references and Move semantics</h4>
<pre><code class="language-cpp">class MyString {
private:
    char* _data;
    ...
public:
    //copy ctor
    MyString(const MyString&amp; str): initialization list {
        ...
    }
    //move ctor
    MyString(MyString&amp;&amp; str) noexcept : initialization list {
        ...
    }//move 完成后,原来的就不可以再次使用了
} 
</code></pre>
<p><img src="https://gile.oss-cn-shanghai.aliyuncs.com/c%2B%2B11/rvalue.png" alt="example move"></p>
<ul>
<li>在<code>c1.insert(ite, Vtype(buf))</code> 中<code>Vtype(buf)</code>是一个临时对象,是一个右值,以后将不再使用,所以走move路线,但是当<code>Vtype(buf)</code>不是一个临时对象,同时确认以后将<strong>不再使用这个对象</strong>时, 如果走<code>move ctor</code>呢?
<ul>
<li>标准库有<code>std::move(c1)</code>这样走的就是<code>move ctor</code></li>
</ul>
</li>
</ul>
<h4 id="perfect-forwarding-完美的转交">Perfect Forwarding 完美的转交</h4>
<ul>
<li>完美转交允许编写一个接受n个任意参数的单个函数模板，并将它们透明地转发给另一个任意函数。并且在转发过程中保留了参数的性质(modifiable、const、lvalue or rvalue)</li>
</ul>
<pre><code class="language-cpp">template&lt;typename T1, typename T2&gt;
void functionA(T1&amp;&amp; t1, T2&amp;&amp; t2){
	functionB(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));
}
</code></pre>
<ul>
<li>什么是不完美呢?</li>
</ul>
<h5 id="unperfect-forwarding">Unperfect Forwarding</h5>
<ul>
<li>所谓不完美,是因为在多层调用中,只有第一层是右值传递,剩下来调用的部分是copy 的处理方式</li>
</ul>
<pre><code class="language-cpp">void process(int&amp; i){	//普通版本
    cout &lt;&lt; &quot;process(int&amp;):&quot; &lt;&lt; i&lt;&lt; endl;
}
void process(int&amp;&amp; i){	//右值引用
    cout &lt;&lt; &quot;process(int&amp;&amp;):&quot; &lt;&lt; i&lt;&lt; endl;
}

void forward(int&amp;&amp; i){
    cout &lt;&lt; &quot;forward(int&amp;&amp;):&quot; &lt;&lt; i &lt;&lt; &quot;, &quot;;
    process(i);  //调用===&gt;process(int&amp; i)
}
//===============================================
int a = 0;	
process(a);	//process(int&amp;):0
process(1);	//process(int&amp;):0
process(move(a));	//process(int&amp;):0

//第二次用到i的时候变成了左值
forward(2);	//forward(int&amp;&amp;): 2, process(int&amp;):2
forward(move(a));//forward(int&amp;&amp;):0, process(int&amp;):0
forward(a);//error cannot bind 'int' lvalue to 'int&amp;&amp;'

process(1);
process(move(a));
</code></pre>
<h4 id="2-写一个move-aware-class">2. 写一个move aware class</h4>
<pre><code class="language-cpp">class MyString { 
private: 
  	char* _data; 
  	size_t _len; 
  	void _init_data(const char *s) { 
    		_data = new char[_len+1]; 
    		memcpy(_data, s, _len); 
    		_data[_len] = '\0'; 
  	} 
public: 
	//default ctor
  	MyString() : _data(NULL), _len(0) {  }

	//ctor
  	MyString(const char* p) : _len(strlen(p)) { 
    	_init_data(p); 
  	} 

	// copy ctor
  	MyString(const MyString&amp; str) : _len(str._len) { 
    	cout &lt;&lt; &quot;Copy Constructor is called! source: &quot; &lt;&lt; str._data &lt;&lt; &quot; [&quot; &lt;&lt; (void*)(str._data) &lt;&lt; ']' &lt;&lt; endl;   	
    	_init_data(str._data); 	//COPY
  	} 

	//move ctor, with &quot;noexcept&quot; 
    MyString(MyString&amp;&amp; str) noexcept : _data(str._data), _len(str._len)  {  
        cout &lt;&lt; &quot;Move Constructor is called! source: &quot; &lt;&lt; str._data &lt;&lt; &quot; [&quot; &lt;&lt; (void*)(str._data) &lt;&lt; ']' &lt;&lt; endl; 
    	str._len = 0; 		
    	str._data = NULL;  	//避免 delete (in dtor) 非常重要重要重要
 	}
 
 	//copy assignment
  	MyString&amp; operator=(const MyString&amp; str) { 
    	cout &lt;&lt; &quot;Copy Assignment is called! source: &quot; &lt;&lt; str._data &lt;&lt; &quot; [&quot; &lt;&lt; (void*)(str._data) &lt;&lt; ']' &lt;&lt; endl; 
		if (this != &amp;str) { //自我赋值检查
    		if (_data) delete _data;  
      		_len = str._len; 
      		_init_data(str._data); 	//COPY! 
    	} 
    	else {
		    cout &lt;&lt; &quot;Self Assignment, Nothing to do.&quot; &lt;&lt; endl;   
		}
    	return *this; 
  	} 

	//move assignment
   	MyString&amp; operator=(MyString&amp;&amp; str) noexcept { 		//注意 noexcept 
     	cout &lt;&lt; &quot;Move Assignment is called&quot; &lt;&lt; str._data &lt;&lt; &quot; [&quot; &lt;&lt; (void*)(str._data) &lt;&lt; ']' &lt;&lt; endl; 
    	if (this != &amp;str) { //自我赋值检查
    		if (_data) delete _data; 
      		_len = str._len; 
      		_data = str._data;	//MOVE!
      		str._len = 0; 
      		str._data = NULL; 	//避免 delete (in dtor) 
    	} 
    	return *this; 
 	}
 
 	//dtor
  	virtual ~MyString() { 	//文檔說需 noexcept 但本處無. destructor is noexcept by default. Johan Lundberg Mar 18 '13 at 12:12    
  	    cout &lt;&lt; &quot;Destructor is called! &quot; &lt;&lt; &quot;source: &quot;; 
  	    if (_data) 	cout &lt;&lt; _data; 
		cout &lt;&lt; &quot; [&quot; &lt;&lt; (void*)(_data) &lt;&lt; ']' &lt;&lt; endl; 
		  	    
    	if (_data) {
    		delete _data; 	
		}
  	}   	
}; 
</code></pre>
<h4 id="3-tuple-用例">3. tuple 用例</h4>
<pre><code class="language-cpp">cout &lt;&lt; &quot;string, sizeof = &quot; &lt;&lt; sizeof(sting) &lt;&lt; endl; //4
cout &lt;&lt; &quot;double, sizeof = &quot; &lt;&lt; sizeof(double) &lt;&lt; endl;//8
cout &lt;&lt; &quot;float, sizeof = &quot; &lt;&lt; sizeof(float) &lt;&lt; endl;//4
cout &lt;&lt; &quot;int, sizeof = &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;//4
cout &lt;&lt; &quot;complex&lt;double&gt;, sizeof = &quot; &lt;&lt; sizeof(complex&lt;double&gt;) &lt;&lt; endl;//16

//tuples
//create a four-element tuple
//elements are initialized with default value
tuple&lt;string, int, int, complex&lt;double&gt;&gt; t;
cout &lt;&lt; &quot;sizeof = &quot;&lt;&lt; sizeof(t) &lt;&lt;endl;	//32, why not 28?  对齐呀

//create and initialize a tuple explicitly
tuple&lt;int, float, string&gt; t1(41, 6.3, &quot;nico&quot;);
cout &lt;&lt; &quot;tuple&lt;int, float, string&gt;, sizeof = &quot;&lt;&lt; sizeof(t1) &lt;&lt;endl;//12

//iterate over elements:
cout &lt;&lt; &quot;t1&quot; &lt;&lt; get&lt;0&gt;(t1)&lt;&lt;' '&lt;&lt; get&lt;1&gt;(t1)&lt;&lt;' '&lt;&lt; get&lt;2&gt;(t1) &lt;&lt;endl;

//create tuple with make_tuple();
auto t2 = make_tuple(22, 44, &quot;stacy&quot;);

//assign second value in t2 to t1
get&lt;1&gt;(t1) = get&lt;1&gt;(t2);

//comparison and assignment
//including type conversion from tuple&lt;int, int, string&gt; to tuple&lt;int, float, string&gt;
if(t1 &lt; t2){	//compares value for value
    cout &lt;&lt; &quot;t1 &lt; t2&quot;&lt;&lt; endl;
} else {
    cout &lt;&lt; &quot;t1 &gt;= t2&quot;&lt;&lt; endl;
}
t1 = t2;	//ok, assigns value for value
cout &lt;&lt; t1 &lt;&lt; endl; // tuple重载&lt;&lt;

tuple&lt;int, float, string&gt; t3(77, 1.1, &quot;more light&quot;);
int i1;
float f1;
string s1;
tie(i1, f1, s1) = t3;	//assigns values of t to i, f, and s


// meta programming
typedef tuple&lt;int, float, string&gt; TupleType;
ocut &lt;&lt; tuple_size&lt;TupleType&gt;::value&lt;&lt;endl;
tuple_element&lt;1, TupleType&gt;::type f1 = 1.0;
typedef tuple_element&lt;1, TupleType&gt;::type T;
</code></pre>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/1.-%E6%8E%92%E5%BA%8F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">排序</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
            <span class="next-text nav-default">MySQL必知必会笔记</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="lyman0522@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
  <a href="http://lyman.fun/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>lyman</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
